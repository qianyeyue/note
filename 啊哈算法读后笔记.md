# 啊哈算法读后笔记

[TOC]

### 1.排序

#### 1.最简单的排序——桶排序

##### 1.过程与思想与原理

1.简单的桶排序就是假设有10个分数，我们就需要10个桶（已经对应分数排列好的桶），对应一个分数一个桶，每有一个分数就往对应的桶里+1，最后桶里的数字就是对应该分数的个数（也就是有几个该分数）

此过程要用到数组。

然后可以按照要求从高到低或从低到高对分数进行排序，按照个数输出

2.综上所述过程为

首先创建一个数组，然后把对应的数字放入到对应的数组中，并且进行数字个数计数。然后按照数组的排列进行输出不同个数的数字，这样输出的数字就已经排列好了。

##### 2.好处和坏处

好处：简单，时间复杂度较小（时间复杂度就是代码总体循环的次数）

坏处：非常浪费空间，所需要申请的变量太多

#### 2.冒泡排序

##### 1.过程与思想与原理

1.基本思想为：每次比较两个相邻的元素，如果他们的顺序错误就把他们交换过来

原理是每一趟只能确定将一个数归位，然后重复这一趟的过程，n个数只用进行n-1趟

2.过程：先创建一个数组，然后将输入的数字放入这个数组中，再进行两个循环，一个是数字进行n-1趟的循环，另一个是第j位数字进行n-i次比较,其中i是正在循环的次数（也就是第i次循环）

3.要注意的是，一个数组里的一个元素组可以有多个元素，比如一个元素组里可以有姓名和分数两个，并且再排序时可以进行整体排序

4.核心是双重嵌套循环

##### 2.好处与坏处

好处：可以进行多个元素整体排序，不浪费空间

坏处：时间复杂度很高

##### 描述一下冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单基础的排序算法。其基本思路是，对于一组要排序的元素列，依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面，如此继续，直到比较到最后的两个数，将小数放在前面，大数放在后面，重复步骤，直至全部排序完成。

这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。

##### **时间复杂度**

若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps1.png)和记录移动次数![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps2.png)均达到最小值：![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps3.png)，![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps4.png)。

所以，冒泡排序最好的时间复杂度为![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps5.png)。

若初始文件是反序的，需要进行![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps6.png)趟排序。每趟排序要进行![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps7.png)次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps8.png) 

![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps9.png) 

冒泡排序的最坏时间复杂度为![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps10.png)。

综上，因此冒泡排序总的平均时间复杂度为![img](file:///C:\Users\DELL\AppData\Local\Temp\ksohtml26368\wps11.png)。

##### 算法稳定性

因为相同元素的前后顺序并没有改变，冒泡排序是一种稳定排序算法。

##### 冒泡排序如何改进

冒泡排序改进1：在某次遍历中如果没有数据交换，说明整个数组已经有序。因此通过设置标志位来记录此次遍历有无数据交换就可以判断是否要继续循环。

 

 冒泡排序改进2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

#### 3.快速排序

##### 1.过程与思想与原理

1.核心思想：将一个数字作为基准数，将大于它的数字放在右边，将小于它的数字放入左边。

 “挖坑填数+分治法”，首先令i =L; j = R; R>L,将a[i]挖出形成第一个坑，称a[i]为基准数。然后j--由后向前找比基准数小的数，找到后挖出此数填入前一个坑a[i]中，再i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。重复进行这种“挖坑填数”直到i==j。再将基准数填入a[i]中，这样i之前的数都比基准数小，i之后的数都比基准数大。因此将数组分成二部分再分别重复上述步骤就完成了排序。

#### 4.选择排序

数组分成有序区和无序区，初始时整个数组都是无序区，然后每次从无序区选一个最小的元素直接放到有序区的最后，直到整个数组变有序区。

#### 5.计数排序

#### 6.基数排序

#### 7.插入排序

**插入排序**原理

每次将一个待排序的数据，跟前面已经有序的序列的数字一一比较找到自己合适的位置，插入到序列中，直到全部数据插入完成。

**希尔排序**原理

先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。由于希尔排序是对相隔若干距离的数据进行直接插入排序，因此可以形象的称希尔排序为“跳着插”

#### 8.归并排序****

  归并排序主要分为两步：分数列（divide），每次把数列一分为二，然后分到只有两个元素的小数列；合数列（Merge），合并两个已经内部有序的子序列，直至所有数字有序。用递归可以实现。

#### 9.堆排序

![](D:\新建文件夹 (2)\图片2.png)

堆的插入就是——每次插入都是将新数据放在数组最后，而从这个新数据的父结点到根结点必定是一个有序的数列，因此只要将这个新数据插入到这个有序数列中即可。

  堆的删除就是——堆的删除就是将最后一个数据的值赋给根结点，然后再从根结点开始进行一次从上向下的调整。调整时先在左右儿子结点中找最小的，如果父结点比这个最小的子结点还小说明不需要调整了，反之将父结点和它交换后再考虑后面的结点。相当于从根结点开始将一个数据在有序数列中进行“下沉”。

  因此，堆的插入和删除非常类似直接插入排序，只不是在二叉树上进行插入过程。所以可以将堆排序形容为“树上插”

#### 介绍一下二分搜索算法(分析一下复杂度)

#### 分析一下排序算法的理论复杂度最快是多少?为什么

![](D:\新建文件夹 (2)\图片1.png)







### 2.队列、栈、链表

#### 1.队列

##### 1.队列的基本元素与性质

###### 1.队列的基本元素：一个数组两个变量（分别是head和tail也就是开头的变量以及队尾的变量）

如下定义：

struct queue{

int data[100];//队列的主体用来储存内容

int head;//队首

int tail;//队尾

}//这个在int main的前面

int main里面为

struct queue q;//struct queue需要整体使用q为结构体变量用.号来访问q中的成员比如

q.head=1;q.tail=1;

scanf("%d",q.data[q.tail]);//就是往q队列中插入数字

###### 2.队列的性质

队列是先进先出的，队列两边都可以出

##### 2.队列的应用

1.如上队列用于实现变化队列的要求

###### 1.广度优先搜索

所谓广度优先搜索，就是从图中的某个顶点出发，寻找紧邻的、尚未访问的顶点，找到多少就访问多少，然后分别从找到的这些顶点出发，继续寻找紧邻的、尚未访问的顶点。

###### 2.队列优化的Bellman-ford 算法（现在无法理解）

Bellman-ford 算法比dijkstra算法更具普遍性，因为它对边没有要求，可以处理负权边与负权回路。缺点是时间复杂度过高

#### 2.栈

##### 1.栈的基本元素与性质

###### 1.栈的基本元素

只需要一个一维数组和一个指向栈顶的top就行

我们通过top对栈进行插入和删除操作

###### 2.栈的性质

栈是先出后进，就像是只有一个开口的桶

栈可以用来判断回文数列，回文数列中点mid前一半入栈

然后将当前栈的字符依次出栈看看能否与mid之后的字符一一匹配

栈用于只有一个进出口的模式

#### 3.链表

##### 1.链表的基本元素与性质

###### 1.基本元素

1.存储动态空间

在C语言中可以用指针和动态分配内存函数malloc实现

指针用于存储一个内存空间的地址比如

double *p;

p=&a;

p就存储了a的地址

malloc用于从内存中申请分配指定字节大小的内存空间

已经有了一个空间，用如下对空间进行操作

int *p;

p=(int *)malloc(sizeof(int));

*p=10;//p中元素为10

使用malloc要用stdlib.h头文件

###### 2.链接的结点构成

结点由两个部分组成

左边用来存放具体的数值

右边存储下一个结点的地址

要定义一个结构体类型来存储这个结点如下

struct node{

int data;//用来存储具体的数值

struct node *next;//用来存储下一个结点的地址

}

###### 3.如何建立链表

1.指针链表

首先需要一个头指针指向链表的开始，当链表还没开始的时候为NULL（即空结点）如下：

struct node *head;

head = NULL;//头指针初始为空

现在创造第一个结点，并用临时结点p指向这个结点

struct node *p，*q;//动态申请一个空间，用来存放一个结点，并用临时指针指向这个结点(p,q类似)

p=(struct node *)malloc(sizeof(struct node));

然后设置新创建的结点的左半部分和右半部分

scanf("%d",&a);

p->data=a;//将数据存储到当前结点的data域中

p->next=NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空

->是结构体指针运算符，也是用来访问结构体内部成员

因为p是一个指针所以不能用.号访问内部成员

if(head==NULL)

head=p;//如果这是一个第一个创建的结点，则将头指针指向这个结点

else

q->next=p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点

q=p;//指针q也指向当前结点

2.模拟链表

也就是构建两个数组data和 right

data用来存放序列中的具体数字

right用来存放当前序列中每一个元素右边的元素在数组data中位置

每多一个数字，放在data的末端，然后判断数字应该在right的哪个位置的右边比如把right[3]改为10

表示新序列中3号元素右边的元素存放在data[10]中，再将right[10]改为4表示新序列中10号元素右边的元素放在data[4]中

运用模拟链表也可以实现双向链表和循环链表

### 3.枚举

#### 1.枚举的应用与原理

##### 1.深度优先搜索

方法为把每一种可能都尝试一遍，当前这一步解决后便进入下一步（访问下一层的位置），当遇到死胡同没有路可走时就返回到初始位置

可以在函数定义中在进行函数调用（也就是自己调用自己），此时用return;表示回到最近一次被调用的地方

用dfs()来解决当时应该怎么办

##### 2.广度优先算法

方法就是在某一处将该处所有的可能（向不同的最靠近该处的方向扩展，访问处于同一层的位置）都进行尝试

然后再进行下一步，并且把之前的可能标记为走过，直至终点。

3.floodfill漫水填充法（不懂）

### 4.//跳过了一章（难啊）

### 5.图的遍历

